---
csrf跨站请求伪造
- 盗取cookie然后伪造用户发送请求
- 直接在受害者浏览器上执行脚本或者修改dom是受害者在不知情的情况下发送get/post请求
---

# 几种防御csrf的策略
## 验证 HTTP Referer 字段（感觉好像用处不大）
> 思路就是验证请求来源，然后如果请求来源不是允许的页面，就会放弃这个请求。  
- 缺点：这种的确可以一定程度上减少csrf攻击，但是，先不说referer字段是可以在一些旧的浏览器或者直接js里面伪造，而且有时用户不会让自己的浏览器发送Referer，这样正常的请求也会受到限制，还有就是这种应该只能防御其他页面对当前页面的csrf，如果就是这个页面出现了csrf，黑客在当前页面form里面加了input，就没办法了。
- 优点：简单易行，不需要大篇幅的修改代码，而且只需要在一些相对敏感的操做验证referer，能有效的减少风险

## token验证
> 思路就是在请求中加入token参数，然后用户提交请求的时候验证这个token，这个token可以是在显示页面的时候随机生成然后放在cookie中，然后用户提交请求的时候也要验证这个参数，验证完成后释放掉这个token，下次需要发出请求得时候在生成一个新的token，然后可以使用js遍历dom树，在需要发起请求请求的地方都加入token，对于get，post等请求都可以加入token  
- 优点: 相对来说是一个比较安全的策略
- 缺点：实现起来相对比较复杂，如果是已经是写好的网站实现起来就非常困难，而且也不是绝对的安全，因为token自身也会像cookie一样被攻击者获取。

## 验证码等二次验证
> 感觉没什么好说的，这样二次确认一下一方面可以让用户清楚自己发送的是什么样的请求，一方面可以防止攻击者通过工具自动化的发送违法的数据包。  

## http头自定义属性并验证
> 这种感觉就是验证Referer和token验证结合起来，实现起来相对复杂，但可能是一个相对安全的策略。

---
差不多就是这些了，感觉除了这些，防御xss也很重要，因为一旦恶意脚本已经在用户的浏览器上执行了，攻击者就能获取相对比较多的信息，或者是在用户页面做一些手脚，这时再去防御csrf就会相对比较困难  
---

# 下面做一些示例，磨练一下代码